# -*- coding: utf-8 -*-
"""CS530_Project1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ruPx01-QeZIL7zAwaOnm_V5WLoMHehDM
"""

import numpy as np
import itertools
import math
from math import ceil
from math import log

# Define fixed parameters
t = 2
v = 2

# Define domain of k
K = [5, 6, 7]

# Define helper variables
f = 0.1

# Define combinations
#combinations = list(itertools.combinations(range(k), t))

# Define objective function
def objective_function(M):
    missing_combinations = 0
    if len(M[0]) < t:
        return missing_combinations
    combinations = list(itertools.combinations(range(len(M[0])), t))
    for subarray in itertools.combinations(M, t):
        submatrix = np.array(subarray)[:, combinations]
        for i in range(v ** t):
            if not np.isin(i, submatrix):
                missing_combinations += 1
                break
    return missing_combinations


# Define neighborhood function
def neighborhood_function(M):
    j = np.random.randint(len(M[0]))
    neighbors = np.copy(M)
    for i in range(len(M)):
        s = np.random.randint(v)
        neighbors[i, j] = s
    return neighbors

# Define SA function
def SA(k):
    # Define initial matrix
    N = k**2  # initial size of the matrix
    M = np.random.randint(v, size=(N, k))

    # Define initial temperature
    Ti = k
    Tf = 0.01
    alpha = 0.99

    # Define counters
    rounds = 0
    frozen_rounds = 0

    # Define best-so-far solution and energy
    best_solution = np.copy(M)
    best_energy = objective_function(M)

    # Define frozen factor
    frozen_factor = (v**t) * math.comb(k, t)

    # Main loop
    while Ti > Tf and frozen_rounds < frozen_factor**2:
        neighbors = [neighborhood_function(M) for _ in range(N)]
        energies = [objective_function(neighbor) for neighbor in neighbors]
        delta_energies = [energies[i] - best_energy for i in range(N)]
        for i in range(N):
            if delta_energies[i] < 0 or np.random.rand() < np.exp(-delta_energies[i] / Ti):
                M = neighbors[i]
                energy = energies[i]
                if energy < best_energy:
                    best_solution = np.copy(M)
                    best_energy = energy
                    frozen_rounds = 0
                else:
                    frozen_rounds += 1
        rounds += 1
        Ti = alpha * Ti

    # Return results
    if best_energy == 0:
        stop_criterion = "solution"
    else:
        stop_criterion = "frozen"
    return best_solution, rounds, stop_criterion

# Run SA for each value of k in K
for k in K:
    best_solution, rounds, stop_criterion = SA(k)
    print(f"k={k}:")
    print(f"Best Solution: {best_solution}")
    print(f"Rounds: {rounds}")
    print(f"Stop Criterion: {stop_criterion}")
